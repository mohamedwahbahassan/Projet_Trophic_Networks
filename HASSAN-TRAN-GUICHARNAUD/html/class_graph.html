<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trophic_Network: RÃ©fÃ©rence de la classe Graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trophic_Network
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- GÃ©nÃ©rÃ© par Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_graph.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pri-attribs">Attributs privÃ©s</a> &#124;
<a href="#friends">Amis</a> &#124;
<a href="class_graph-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">RÃ©fÃ©rence de la classe Graph</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a6d716090e2ae19abf6b40b5f1a7f7f68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6d716090e2ae19abf6b40b5f1a7f7f68">Graph</a> (<a class="el" href="class_graph_interface.html">GraphInterface</a> *interface=nullptr)</td></tr>
<tr class="separator:a6d716090e2ae19abf6b40b5f1a7f7f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4a2a7c5e48ccf743c0405be7d0d5e"><td class="memItemLeft" align="right" valign="top"><a id="a7be4a2a7c5e48ccf743c0405be7d0d5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7be4a2a7c5e48ccf743c0405be7d0d5e">add_interfaced_vertex</a> (int idx, double value, int x, int y, std::string pic_name=&quot;&quot;, int pic_idx=0, float rythmeCroissance=0, float coeffPondere=0)</td></tr>
<tr class="memdesc:a7be4a2a7c5e48ccf743c0405be7d0d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aide à l'ajout de sommets interfacés <br /></td></tr>
<tr class="separator:a7be4a2a7c5e48ccf743c0405be7d0d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa824f04c8fd5a315f23f4af61db9c301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa824f04c8fd5a315f23f4af61db9c301">add_interfaced_edge</a> (int idx, int vert1, int vert2, double weight=0)</td></tr>
<tr class="memdesc:aa824f04c8fd5a315f23f4af61db9c301"><td class="mdescLeft">&#160;</td><td class="mdescRight">changed by jojo  <a href="#aa824f04c8fd5a315f23f4af61db9c301">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:aa824f04c8fd5a315f23f4af61db9c301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039fbc741962201598e0b3adde57c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae039fbc741962201598e0b3adde57c24">chargerFichier</a> (int ordre, int restauration)</td></tr>
<tr class="separator:ae039fbc741962201598e0b3adde57c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e825cef072ca54283e87f261e07440"><td class="memItemLeft" align="right" valign="top"><a id="ae3e825cef072ca54283e87f261e07440"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sauverFichier</b> (int ordre, int restauration)</td></tr>
<tr class="separator:ae3e825cef072ca54283e87f261e07440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882fff08678cb85651f28eae278e62a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a882fff08678cb85651f28eae278e62a6">remove_edge</a> (int eidx, int cas)</td></tr>
<tr class="memdesc:a882fff08678cb85651f28eae278e62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">eidx index of edge to remove  <a href="#a882fff08678cb85651f28eae278e62a6">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a882fff08678cb85651f28eae278e62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b93af5c5904031686de3ec9c153046d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5b93af5c5904031686de3ec9c153046d">remove_vertex</a> (int eidx, int cas)</td></tr>
<tr class="separator:a5b93af5c5904031686de3ec9c153046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d07e8479716458fa5c2433fec30a7"><td class="memItemLeft" align="right" valign="top"><a id="a422d07e8479716458fa5c2433fec30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vider_graph</b> ()</td></tr>
<tr class="separator:a422d07e8479716458fa5c2433fec30a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90afdbc52c3a53e41ee50a9601d48665"><td class="memItemLeft" align="right" valign="top"><a id="a90afdbc52c3a53e41ee50a9601d48665"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_vertex</b> (std::string image)</td></tr>
<tr class="separator:a90afdbc52c3a53e41ee50a9601d48665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0635aa4739c7c9b9b476f1f2213a07"><td class="memItemLeft" align="right" valign="top"><a id="abf0635aa4739c7c9b9b476f1f2213a07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_edge</b> (int from, int to)</td></tr>
<tr class="separator:abf0635aa4739c7c9b9b476f1f2213a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b2b52cbbdd6048dfcee5e8f7a72782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac8b2b52cbbdd6048dfcee5e8f7a72782">WraperBoutons</a> ()</td></tr>
<tr class="separator:ac8b2b52cbbdd6048dfcee5e8f7a72782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64357363839d1dc7fce740a3333b2c5"><td class="memItemLeft" align="right" valign="top"><a id="aa64357363839d1dc7fce740a3333b2c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>changement_int</b> (float val)</td></tr>
<tr class="separator:aa64357363839d1dc7fce740a3333b2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fa1e332c0475aef878dfd913b18c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a57fa1e332c0475aef878dfd913b18c82">remplir_tab_adj</a> ()</td></tr>
<tr class="memdesc:a57fa1e332c0475aef878dfd913b18c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour remplir le tableau d'adjaence  <a href="#a57fa1e332c0475aef878dfd913b18c82">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a57fa1e332c0475aef878dfd913b18c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357f45443c2007210ffb24fc76e1a2b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a357f45443c2007210ffb24fc76e1a2b7">uneComposanteFortementConnexe</a> (int s)</td></tr>
<tr class="memdesc:a357f45443c2007210ffb24fc76e1a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode permettant de trouver une compsante fortement connexe  <a href="#a357f45443c2007210ffb24fc76e1a2b7">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a357f45443c2007210ffb24fc76e1a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc48e35c7f5c6b41fd13da140fe138e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3cc48e35c7f5c6b41fd13da140fe138e">toutesLesComposantesFortementConnexes</a> ()</td></tr>
<tr class="memdesc:a3cc48e35c7f5c6b41fd13da140fe138e"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode permettant de trouver toutes les compsantes fortement connexe  <a href="#a3cc48e35c7f5c6b41fd13da140fe138e">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3cc48e35c7f5c6b41fd13da140fe138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec6286e01b506fbcd3c8c9e13a1be77"><td class="memItemLeft" align="right" valign="top"><a id="acec6286e01b506fbcd3c8c9e13a1be77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>affichageTableauForteConnexite</b> ()</td></tr>
<tr class="separator:acec6286e01b506fbcd3c8c9e13a1be77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cc5ed76bf5dc881c7b13c89ff7f703"><td class="memItemLeft" align="right" valign="top"><a id="ac3cc5ed76bf5dc881c7b13c89ff7f703"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>affichageForteConnexiteInterface</b> (bool actif)</td></tr>
<tr class="separator:ac3cc5ed76bf5dc881c7b13c89ff7f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6e8e943f72df594b8f8dd057e81e59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aff6e8e943f72df594b8f8dd057e81e59">GraphReduit</a> ()</td></tr>
<tr class="separator:aff6e8e943f72df594b8f8dd057e81e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387b4364cdf604f82523e079a1d39f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a387b4364cdf604f82523e079a1d39f91">menu_ajout_vertex</a> ()</td></tr>
<tr class="separator:a387b4364cdf604f82523e079a1d39f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70a037b7811f162a7b8fa92ca9e79ef"><td class="memItemLeft" align="right" valign="top"><a id="ad70a037b7811f162a7b8fa92ca9e79ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>menu_ajout_edge</b> ()</td></tr>
<tr class="separator:ad70a037b7811f162a7b8fa92ca9e79ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766818f15196623e2929d723f495116c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a766818f15196623e2929d723f495116c">ordredebase</a> ()</td></tr>
<tr class="memdesc:a766818f15196623e2929d723f495116c"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour recupérer l'ordre à un instant t  <a href="#a766818f15196623e2929d723f495116c">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a766818f15196623e2929d723f495116c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4fe3e0f119971649ed33e3c364cde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a97b4fe3e0f119971649ed33e3c364cde">update</a> ()</td></tr>
<tr class="memdesc:a97b4fe3e0f119971649ed33e3c364cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">La méthode update à appeler dans la boucle de jeu pour les graphes avec interface.  <a href="#a97b4fe3e0f119971649ed33e3c364cde">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a97b4fe3e0f119971649ed33e3c364cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025e0323a2915fbb5d74d762316ea513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a025e0323a2915fbb5d74d762316ea513">boutons</a> ()</td></tr>
<tr class="separator:a025e0323a2915fbb5d74d762316ea513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967df8cd780111dee15c45c40d43d56b"><td class="memItemLeft" align="right" valign="top"><a id="a967df8cd780111dee15c45c40d43d56b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MenuPrincipal</b> ()</td></tr>
<tr class="separator:a967df8cd780111dee15c45c40d43d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92cf6741ebe1a3322e3d0ad08bc5fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8a92cf6741ebe1a3322e3d0ad08bc5fc">CalculPop</a> ()</td></tr>
<tr class="memdesc:a8a92cf6741ebe1a3322e3d0ad08bc5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction qui calcul la population en fonction des populations des autres sommets et coefficients des autres arcs.  <a href="#a8a92cf6741ebe1a3322e3d0ad08bc5fc">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a8a92cf6741ebe1a3322e3d0ad08bc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ad0f9d740124db040cc0edcbd23dc6"><td class="memItemLeft" align="right" valign="top"><a id="a50ad0f9d740124db040cc0edcbd23dc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnregistrementGraph</b> ()</td></tr>
<tr class="separator:a50ad0f9d740124db040cc0edcbd23dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210149c7d494f832325ba847959e56bb"><td class="memItemLeft" align="right" valign="top"><a id="a210149c7d494f832325ba847959e56bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AffPop</b> ()</td></tr>
<tr class="separator:a210149c7d494f832325ba847959e56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eff44a2dc0eb3832c9ee989a6cf8220"><td class="memItemLeft" align="right" valign="top"><a id="a7eff44a2dc0eb3832c9ee989a6cf8220"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_quiter</b> ()</td></tr>
<tr class="separator:a7eff44a2dc0eb3832c9ee989a6cf8220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b6662d6322ce263c9073ac2cbaf43"><td class="memItemLeft" align="right" valign="top"><a id="a205b6662d6322ce263c9073ac2cbaf43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_restaurer_graph</b> ()</td></tr>
<tr class="separator:a205b6662d6322ce263c9073ac2cbaf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ffde0270693c553f52b63bd803f8d1"><td class="memItemLeft" align="right" valign="top"><a id="a05ffde0270693c553f52b63bd803f8d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_sauver</b> ()</td></tr>
<tr class="separator:a05ffde0270693c553f52b63bd803f8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab1aaeafae4acd523329d58bfb6c658"><td class="memItemLeft" align="right" valign="top"><a id="abab1aaeafae4acd523329d58bfb6c658"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_playEvolution</b> ()</td></tr>
<tr class="separator:abab1aaeafae4acd523329d58bfb6c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb33bfc7e4b8e53d004c8f905e443707"><td class="memItemLeft" align="right" valign="top"><a id="aeb33bfc7e4b8e53d004c8f905e443707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_vitEvolution</b> ()</td></tr>
<tr class="separator:aeb33bfc7e4b8e53d004c8f905e443707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9510e800fab4a25b86962c19cd43fb1a"><td class="memItemLeft" align="right" valign="top"><a id="a9510e800fab4a25b86962c19cd43fb1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_montrerComposantesFortementConnexe</b> ()</td></tr>
<tr class="separator:a9510e800fab4a25b86962c19cd43fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e1361a9126ad065dee420faf21d46"><td class="memItemLeft" align="right" valign="top"><a id="aec4e1361a9126ad065dee420faf21d46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RAZ_graphReduit</b> ()</td></tr>
<tr class="separator:aec4e1361a9126ad065dee420faf21d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953a06cdd34c6c7c20d39933cb75cb0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a953a06cdd34c6c7c20d39933cb75cb0a">evolution</a> (bool *pause, int *rest_evolution, int *t1)</td></tr>
<tr class="separator:a953a06cdd34c6c7c20d39933cb75cb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632bf261afa3d9e6afd6cfa3a618ce1a"><td class="memItemLeft" align="right" valign="top"><a id="a632bf261afa3d9e6afd6cfa3a618ce1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_current_graph</b> (int var)</td></tr>
<tr class="separator:a632bf261afa3d9e6afd6cfa3a618ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08038204e70ba7fd5e88ce3ac0148fd6"><td class="memItemLeft" align="right" valign="top"><a id="a08038204e70ba7fd5e88ce3ac0148fd6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_autorisation_supr_edge</b> ()</td></tr>
<tr class="separator:a08038204e70ba7fd5e88ce3ac0148fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dde12efb1e3117173974314842625b"><td class="memItemLeft" align="right" valign="top"><a id="a31dde12efb1e3117173974314842625b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_restaurer_graph</b> ()</td></tr>
<tr class="separator:a31dde12efb1e3117173974314842625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8a52e863fab6ecbec32882acffb0e"><td class="memItemLeft" align="right" valign="top"><a id="a9dd8a52e863fab6ecbec32882acffb0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_sauver</b> ()</td></tr>
<tr class="separator:a9dd8a52e863fab6ecbec32882acffb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9601372a095544c083305db2684e37e9"><td class="memItemLeft" align="right" valign="top"><a id="a9601372a095544c083305db2684e37e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_quiter</b> ()</td></tr>
<tr class="separator:a9601372a095544c083305db2684e37e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2ae854daca125d251e5fd29627c307"><td class="memItemLeft" align="right" valign="top"><a id="a3f2ae854daca125d251e5fd29627c307"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_montrerComposantesFortementConnexe</b> ()</td></tr>
<tr class="separator:a3f2ae854daca125d251e5fd29627c307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd525b1ed51176b07292ac65a2d98207"><td class="memItemLeft" align="right" valign="top"><a id="afd525b1ed51176b07292ac65a2d98207"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_graphReduit</b> ()</td></tr>
<tr class="separator:afd525b1ed51176b07292ac65a2d98207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0282b1f91d806c9b656e25272ca4edd"><td class="memItemLeft" align="right" valign="top"><a id="ad0282b1f91d806c9b656e25272ca4edd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_playEvolution</b> ()</td></tr>
<tr class="separator:ad0282b1f91d806c9b656e25272ca4edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55489f6f211b81ab94d536175fde5d38"><td class="memItemLeft" align="right" valign="top"><a id="a55489f6f211b81ab94d536175fde5d38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_vitEvolutionMoins</b> ()</td></tr>
<tr class="separator:a55489f6f211b81ab94d536175fde5d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb948bedd7a4d42064e2ca63b37b93e"><td class="memItemLeft" align="right" valign="top"><a id="a5bb948bedd7a4d42064e2ca63b37b93e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_vitEvolutionPlus</b> ()</td></tr>
<tr class="separator:a5bb948bedd7a4d42064e2ca63b37b93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f006944d29eaab7a148a7c49c2693"><td class="memItemLeft" align="right" valign="top"><a id="afa4f006944d29eaab7a148a7c49c2693"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_graph</b> ()</td></tr>
<tr class="separator:afa4f006944d29eaab7a148a7c49c2693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f38ee6feb9ba496c5747875b4daeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae44f38ee6feb9ba496c5747875b4daeb">remplir_tab_adj_sym</a> ()</td></tr>
<tr class="memdesc:ae44f38ee6feb9ba496c5747875b4daeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour remplir le tableau d'adjacence symétrique  <a href="#ae44f38ee6feb9ba496c5747875b4daeb">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:ae44f38ee6feb9ba496c5747875b4daeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa2a4e949cf2c6fef1d3c6b6aff000"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1ffa2a4e949cf2c6fef1d3c6b6aff000">remplir_tab_connexe</a> (int s)</td></tr>
<tr class="memdesc:a1ffa2a4e949cf2c6fef1d3c6b6aff000"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour remplir le tableau de connexité  <a href="#a1ffa2a4e949cf2c6fef1d3c6b6aff000">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a1ffa2a4e949cf2c6fef1d3c6b6aff000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74bb1df0d66fa27dc8459692b4d7fd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac74bb1df0d66fa27dc8459692b4d7fd9">Graphe_connexe</a> ()</td></tr>
<tr class="memdesc:ac74bb1df0d66fa27dc8459692b4d7fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour savoir si le graphe est connexe ou pas en retournant 0 ou 1  <a href="#ac74bb1df0d66fa27dc8459692b4d7fd9">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:ac74bb1df0d66fa27dc8459692b4d7fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af8b138a6b780b88fdc235c93a1f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af6af8b138a6b780b88fdc235c93a1f0c">chercher_sommet_actif</a> ()</td></tr>
<tr class="memdesc:af6af8b138a6b780b88fdc235c93a1f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour trouver un sommet de reference qui existe dans l'interface d'une maniere arbitraire  <a href="#af6af8b138a6b780b88fdc235c93a1f0c">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:af6af8b138a6b780b88fdc235c93a1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb54b35d5f4b30bcf351b9cbd26d334c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abb54b35d5f4b30bcf351b9cbd26d334c">getCombinFork</a> (const std::string &amp;serie, size_t i, std::string result, int *compteur)</td></tr>
<tr class="memdesc:abb54b35d5f4b30bcf351b9cbd26d334c"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour trouver toutes les combinaisons possibles d'un k precis  <a href="#abb54b35d5f4b30bcf351b9cbd26d334c">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:abb54b35d5f4b30bcf351b9cbd26d334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7daeee0b597e67aac5094010399332c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af7daeee0b597e67aac5094010399332c">getAllCombin</a> (std::string serie)</td></tr>
<tr class="memdesc:af7daeee0b597e67aac5094010399332c"><td class="mdescLeft">&#160;</td><td class="mdescRight">methode pour trouver toutes les combianaisons possibles de tous les k possibles en appelant le sous programma au dessus  <a href="#af7daeee0b597e67aac5094010399332c">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:af7daeee0b597e67aac5094010399332c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7858bc4b4e4f6990f298fa1f95cb5dea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7858bc4b4e4f6990f298fa1f95cb5dea">get_serie</a> ()</td></tr>
<tr class="separator:a7858bc4b4e4f6990f298fa1f95cb5dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92547395946cf1424a39c74c63476ee7"><td class="memItemLeft" align="right" valign="top"><a id="a92547395946cf1424a39c74c63476ee7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a92547395946cf1424a39c74c63476ee7">affichage_tab_combin</a> ()</td></tr>
<tr class="memdesc:a92547395946cf1424a39c74c63476ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">on affiche le tableau conteant les sommets de k-connexité <br /></td></tr>
<tr class="separator:a92547395946cf1424a39c74c63476ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc638aae5d02129a9c4bc4babef02039"><td class="memItemLeft" align="right" valign="top"><a id="acc638aae5d02129a9c4bc4babef02039"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acc638aae5d02129a9c4bc4babef02039">initialise_tab_combine</a> ()</td></tr>
<tr class="memdesc:acc638aae5d02129a9c4bc4babef02039"><td class="mdescLeft">&#160;</td><td class="mdescRight">on initialise ce tableau <br /></td></tr>
<tr class="separator:acc638aae5d02129a9c4bc4babef02039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Attributs privÃ©s</h2></td></tr>
<tr class="memitem:a1ad9a199cc12510a6a1837dfb0ea8375"><td class="memItemLeft" align="right" valign="top"><a id="a1ad9a199cc12510a6a1837dfb0ea8375"></a>
std::map&lt; int, <a class="el" href="class_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1ad9a199cc12510a6a1837dfb0ea8375">m_edges</a></td></tr>
<tr class="memdesc:a1ad9a199cc12510a6a1837dfb0ea8375"><td class="mdescLeft">&#160;</td><td class="mdescRight">La "liste" des arêtes. <br /></td></tr>
<tr class="separator:a1ad9a199cc12510a6a1837dfb0ea8375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52afc25370799d38d09dbadfada935f7"><td class="memItemLeft" align="right" valign="top"><a id="a52afc25370799d38d09dbadfada935f7"></a>
std::map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a52afc25370799d38d09dbadfada935f7">m_vertices</a></td></tr>
<tr class="memdesc:a52afc25370799d38d09dbadfada935f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">La liste des sommets. <br /></td></tr>
<tr class="separator:a52afc25370799d38d09dbadfada935f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97d1e6394b7d4fc52dcb933148113ed"><td class="memItemLeft" align="right" valign="top"><a id="aa97d1e6394b7d4fc52dcb933148113ed"></a>
std::shared_ptr&lt; <a class="el" href="class_graph_interface.html">GraphInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa97d1e6394b7d4fc52dcb933148113ed">m_interface</a> = nullptr</td></tr>
<tr class="memdesc:aa97d1e6394b7d4fc52dcb933148113ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">le POINTEUR sur l'interface associée, nullptr -&gt; pas d'interface <br /></td></tr>
<tr class="separator:aa97d1e6394b7d4fc52dcb933148113ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23839d423d4d44680392193c02908dd"><td class="memItemLeft" align="right" valign="top"><a id="ac23839d423d4d44680392193c02908dd"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac23839d423d4d44680392193c02908dd">m_tab_adj</a></td></tr>
<tr class="memdesc:ac23839d423d4d44680392193c02908dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">un tableau dynamique de 2 dimensions pour l'adjacence <br /></td></tr>
<tr class="separator:ac23839d423d4d44680392193c02908dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42044dc64408ef1dc85bb7be230a380b"><td class="memItemLeft" align="right" valign="top"><a id="a42044dc64408ef1dc85bb7be230a380b"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a42044dc64408ef1dc85bb7be230a380b">m_tab_forte_connexite</a></td></tr>
<tr class="memdesc:a42044dc64408ef1dc85bb7be230a380b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tableau dynamique de 2 dimensions pour la forte connexe <br /></td></tr>
<tr class="separator:a42044dc64408ef1dc85bb7be230a380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a1769dc34b7ad7d2bb8f480ef65c76"><td class="memItemLeft" align="right" valign="top"><a id="ab8a1769dc34b7ad7d2bb8f480ef65c76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab8a1769dc34b7ad7d2bb8f480ef65c76">m_ordre</a></td></tr>
<tr class="memdesc:ab8a1769dc34b7ad7d2bb8f480ef65c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">le nombre de sommets d'un graphe <br /></td></tr>
<tr class="separator:ab8a1769dc34b7ad7d2bb8f480ef65c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ba14254ba687723c15de2086736fa"><td class="memItemLeft" align="right" valign="top"><a id="a3c2ba14254ba687723c15de2086736fa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_restaurer_graph</b> = false</td></tr>
<tr class="separator:a3c2ba14254ba687723c15de2086736fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dd382b2b982c9b4ecad47850f440a7"><td class="memItemLeft" align="right" valign="top"><a id="a51dd382b2b982c9b4ecad47850f440a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_sauver</b> = false</td></tr>
<tr class="separator:a51dd382b2b982c9b4ecad47850f440a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f41b0892b3f360d4a1c28c506c3449"><td class="memItemLeft" align="right" valign="top"><a id="a75f41b0892b3f360d4a1c28c506c3449"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_quiter</b> = false</td></tr>
<tr class="separator:a75f41b0892b3f360d4a1c28c506c3449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd274ce4a71d047e2753277d23d5fd1"><td class="memItemLeft" align="right" valign="top"><a id="aecd274ce4a71d047e2753277d23d5fd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_SuprEdge</b> = false</td></tr>
<tr class="separator:aecd274ce4a71d047e2753277d23d5fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee763c4696948021fac5403d4aaae02"><td class="memItemLeft" align="right" valign="top"><a id="aeee763c4696948021fac5403d4aaae02"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_AjoutVertex</b> = false</td></tr>
<tr class="separator:aeee763c4696948021fac5403d4aaae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996044a0e024fa06ae69518dfdda6b2a"><td class="memItemLeft" align="right" valign="top"><a id="a996044a0e024fa06ae69518dfdda6b2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_AjoutEdge</b> = false</td></tr>
<tr class="separator:a996044a0e024fa06ae69518dfdda6b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594dcb468576ba84d5551f55776b8f5"><td class="memItemLeft" align="right" valign="top"><a id="a2594dcb468576ba84d5551f55776b8f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_montrerComposantesConnexe</b> = false</td></tr>
<tr class="separator:a2594dcb468576ba84d5551f55776b8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0bdd00d84f720ba1fc3cdf541a7665"><td class="memItemLeft" align="right" valign="top"><a id="aff0bdd00d84f720ba1fc3cdf541a7665"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_graphReduit</b> = false</td></tr>
<tr class="separator:aff0bdd00d84f720ba1fc3cdf541a7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1767636a93ea6311be4ba3247131445e"><td class="memItemLeft" align="right" valign="top"><a id="a1767636a93ea6311be4ba3247131445e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stopGraphReduit</b> = false</td></tr>
<tr class="separator:a1767636a93ea6311be4ba3247131445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6ea253a70e80f8e26df2741cc614d"><td class="memItemLeft" align="right" valign="top"><a id="a2af6ea253a70e80f8e26df2741cc614d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_mouse_prec</b> = false</td></tr>
<tr class="separator:a2af6ea253a70e80f8e26df2741cc614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7d51a433f1d7bd9924a0b43acfd2b9"><td class="memItemLeft" align="right" valign="top"><a id="abd7d51a433f1d7bd9924a0b43acfd2b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_CurrentGraph</b></td></tr>
<tr class="separator:abd7d51a433f1d7bd9924a0b43acfd2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa20d63e82d1ae327a230aac6d2becb4"><td class="memItemLeft" align="right" valign="top"><a id="afa20d63e82d1ae327a230aac6d2becb4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_playEvolution</b> = false</td></tr>
<tr class="separator:afa20d63e82d1ae327a230aac6d2becb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b1b0d85f8e457f0074519512a54c3"><td class="memItemLeft" align="right" valign="top"><a id="a040b1b0d85f8e457f0074519512a54c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_vitEvolutionPlus</b> = false</td></tr>
<tr class="separator:a040b1b0d85f8e457f0074519512a54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea34a52a9cfc5fd483d3f52c18a4e96"><td class="memItemLeft" align="right" valign="top"><a id="abea34a52a9cfc5fd483d3f52c18a4e96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_vitEvolutionMoins</b> = false</td></tr>
<tr class="separator:abea34a52a9cfc5fd483d3f52c18a4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd26a0144f67a4ac5112ffe1c02d02f"><td class="memItemLeft" align="right" valign="top"><a id="acfd26a0144f67a4ac5112ffe1c02d02f"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acfd26a0144f67a4ac5112ffe1c02d02f">m_tab_adj_sym</a></td></tr>
<tr class="memdesc:acfd26a0144f67a4ac5112ffe1c02d02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tableau dynamique de 2 dimensions pour l'adjacence en supposant que le graphe est non orienté <br /></td></tr>
<tr class="separator:acfd26a0144f67a4ac5112ffe1c02d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64785f8c85fd8cfc1270ad4adc759762"><td class="memItemLeft" align="right" valign="top"><a id="a64785f8c85fd8cfc1270ad4adc759762"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a64785f8c85fd8cfc1270ad4adc759762">m_tab_connexe</a></td></tr>
<tr class="memdesc:a64785f8c85fd8cfc1270ad4adc759762"><td class="mdescLeft">&#160;</td><td class="mdescRight">tableau dynamique indiquant depuis un sommet de référence s'il est connexe ou pas aux autres sommets (binaire 0 ou 1) <br /></td></tr>
<tr class="separator:a64785f8c85fd8cfc1270ad4adc759762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7638dbbff54d7162eb8146d64d399660"><td class="memItemLeft" align="right" valign="top"><a id="a7638dbbff54d7162eb8146d64d399660"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7638dbbff54d7162eb8146d64d399660">m_tabCombin</a></td></tr>
<tr class="memdesc:a7638dbbff54d7162eb8146d64d399660"><td class="mdescLeft">&#160;</td><td class="mdescRight">tableau dynamique indiquant quels sommets qu'on pourra supprimer pour rendre le graphe non connexe <br /></td></tr>
<tr class="separator:a7638dbbff54d7162eb8146d64d399660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amis</h2></td></tr>
<tr class="memitem:a1251d18f08324022e8e73506c3768f3c"><td class="memItemLeft" align="right" valign="top"><a id="a1251d18f08324022e8e73506c3768f3c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:a1251d18f08324022e8e73506c3768f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748f97d45d6ef457da5e2f88aac4899"><td class="memItemLeft" align="right" valign="top"><a id="a1748f97d45d6ef457da5e2f88aac4899"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>VertexInterface</b></td></tr>
<tr class="separator:a1748f97d45d6ef457da5e2f88aac4899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c8ba04c9d9989ccbf3c5aba267a3d7"><td class="memItemLeft" align="right" valign="top"><a id="ad2c8ba04c9d9989ccbf3c5aba267a3d7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:ad2c8ba04c9d9989ccbf3c5aba267a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1edfb3728013ee10d1d7fb1fb89585"><td class="memItemLeft" align="right" valign="top"><a id="a8e1edfb3728013ee10d1d7fb1fb89585"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeInterface</b></td></tr>
<tr class="separator:a8e1edfb3728013ee10d1d7fb1fb89585"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="a6d716090e2ae19abf6b40b5f1a7f7f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d716090e2ae19abf6b40b5f1a7f7f68">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph_interface.html">GraphInterface</a> *&#160;</td>
          <td class="paramname"><em>interface</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Les constructeurs sont à compléter selon vos besoin... Ici on ne donne qu'un seul constructeur qui peut utiliser une interface </p>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="aa824f04c8fd5a315f23f4af61db9c301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa824f04c8fd5a315f23f4af61db9c301">&#9670;&nbsp;</a></span>add_interfaced_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::add_interfaced_edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vert1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vert2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changed by jojo </p>
<p>Aide à l'ajout d'arcs interfacés </p>

</div>
</div>
<a id="a025e0323a2915fbb5d74d762316ea513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025e0323a2915fbb5d74d762316ea513">&#9670;&nbsp;</a></span>boutons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::boutons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>on a appuyé suir le bouton quiter</p>
<p>on a appuyé sur le bouton pour montrer les composantes fortement connexe</p>
<p>cas ou o'on reste appuyé sur le bouton. on attends de relacher le bouton avant d'effacer les couleurs</p>
<p>on a appuyé sur le bouton graph réduit</p>
<p>on a appuyé sur le bouton restaurer</p>
<p>on a appuyé sur le bouton sauvegarder </p>

</div>
</div>
<a id="a8a92cf6741ebe1a3322e3d0ad08bc5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92cf6741ebe1a3322e3d0ad08bc5fc">&#9670;&nbsp;</a></span>CalculPop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::CalculPop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction qui calcul la population en fonction des populations des autres sommets et coefficients des autres arcs. </p>
<p>Fonction: permet de calculer la population en temps réel en fonction de la population de départ. </p>
<p>Calcul de la capacité de portage de l'environnement</p>
<p>ex: K lapin = Coeff(herbe-&gt;lapin)* N herbe : Capacité = Poids de l'arc entrante * valeur du sommet 1 de l'arc entrante</p>
<p>m_edges[e.second.m_in[i]].m_from = indice du sommet 1 de l'arc entrante</p>
<p>Calcul de la quantité consommée</p>
<p>ex: K2 herbe= Coeff (herbe-&gt;lapin)* N lapin : Quantité consommée = Poids de l'arc sortante * valeur du sommet 2 de l'arc sortante</p>
<p>AFFICHAGE DU CALCUL DE LA QUANTITE CONSOMMEE</p>
<p>Calcul de l'évolution de la population à partir d'un certain temps t</p>
<p>10 % de la population meurt chq année</p>
<p>R * N (1 - N/K)</p>
<p>R2*CoeffPondere</p>
<p>Mort de Vieillesse</p>
<p>si la capacité de portage est égale à 0 et que ce n'est pas un végétal (on ne peut pas diviser par 0)</p>
<p>Si la capacité de portage de l'environnement est égale à 0, l'espèce meurt</p>
<p>Si on obtient une population négative, value=0</p>
<p>AFFICHAGE DES CALCULS </p>

</div>
</div>
<a id="ae039fbc741962201598e0b3adde57c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae039fbc741962201598e0b3adde57c24">&#9670;&nbsp;</a></span>chargerFichier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::chargerFichier </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ordre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>restauration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add by jojo</p>
<p>Rythme Croissance</p>
<p>Coeff Pondéré</p>
<p>add by jojo</p>
<p>Changed by jojo </p>

</div>
</div>
<a id="af6af8b138a6b780b88fdc235c93a1f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6af8b138a6b780b88fdc235c93a1f0c">&#9670;&nbsp;</a></span>chercher_sommet_actif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::chercher_sommet_actif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour trouver un sommet de reference qui existe dans l'interface d'une maniere arbitraire </p>
<p>pour trouver un sommet actif arbitrairement pour qu'il joue le role d'un sommet de référence </p>
<p>on parcours la map de sommet</p>
<p>on retourne le premier sommet actif </p>

</div>
</div>
<a id="a953a06cdd34c6c7c20d39933cb75cb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953a06cdd34c6c7c20d39933cb75cb0a">&#9670;&nbsp;</a></span>evolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::evolution </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rest_evolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SIMULATION DE L'EVOLUTION DES POPULATIONS</p>
<p>quand on clique, change l'état du boolen play/pause</p>
<p>accelerer/ralentir la vitesse d'évolution</p>
<p>accélere</p>
<p>ralentir </p>

</div>
</div>
<a id="a7858bc4b4e4f6990f298fa1f95cb5dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7858bc4b4e4f6990f298fa1f95cb5dea">&#9670;&nbsp;</a></span>get_serie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Graph::get_serie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>on déclare une variable de type string qu'on le met à vide au début</p>
<p>on parcourt la map de sommets</p>
<p>on remplit la variable de type string avec toutes les indices de sommets de la map de vertice </p>

</div>
</div>
<a id="af7daeee0b597e67aac5094010399332c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7daeee0b597e67aac5094010399332c">&#9670;&nbsp;</a></span>getAllCombin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::getAllCombin </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>serie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour trouver toutes les combianaisons possibles de tous les k possibles en appelant le sous programma au dessus </p>
<p>//chercher toutes les combinaisons possible de la série pour chq k </p>

</div>
</div>
<a id="abb54b35d5f4b30bcf351b9cbd26d334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb54b35d5f4b30bcf351b9cbd26d334c">&#9670;&nbsp;</a></span>getCombinFork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::getCombinFork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>compteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour trouver toutes les combinaisons possibles d'un k precis </p>
<p>avec i= k = le nombre d'élements dans n ///j:la taille de la série</p>
<p>Si i=1, afficher les n éléments de la série</p>
<p>Si la série ne possède pas assez d'élément (on envoie k&gt;n), la fonction crache</p>
<p>Fonction récursive qui se rappelle elle même, avec la taille de la chaine=j+1 </p>

</div>
</div>
<a id="ac74bb1df0d66fa27dc8459692b4d7fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74bb1df0d66fa27dc8459692b4d7fd9">&#9670;&nbsp;</a></span>Graphe_connexe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::Graphe_connexe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour savoir si le graphe est connexe ou pas en retournant 0 ou 1 </p>
<p>on déclare un compteur de type int et un booléen connexe</p>
<p>on remplit le tableau de connexité en donnant comme paramètre le premier sommet actif dans la map</p>
<p>on parcourt le tableau de connexité</p>
<p>si à l'indice i, on a 1</p>
<p>on incremente le compteur</p>
<p>si le comteur est égal au nombre de ligne de tableau de connexité cad que le graphe est connexe car le sommet de ref est connexe à tous les sommets</p>
<p>on met le booleen à true</p>
<p>sinon on met le booleen à false </p>

</div>
</div>
<a id="aff6e8e943f72df594b8f8dd057e81e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6e8e943f72df594b8f8dd057e81e59">&#9670;&nbsp;</a></span>GraphReduit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::GraphReduit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>std::cout &lt;&lt; "\ncas n3 " &lt;&lt; it-&gt;first; </p>

</div>
</div>
<a id="a387b4364cdf604f82523e079a1d39f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387b4364cdf604f82523e079a1d39f91">&#9670;&nbsp;</a></span>menu_ajout_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::menu_ajout_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On la compare avec la database</p>
<p>DESERT</p>
<p>SAVANE</p>
<p>BANQUISE </p>

</div>
</div>
<a id="a766818f15196623e2929d723f495116c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766818f15196623e2929d723f495116c">&#9670;&nbsp;</a></span>ordredebase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::ordredebase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour recupérer l'ordre à un instant t </p>
<p>on recupère l'ordre du graphe </p>

</div>
</div>
<a id="a882fff08678cb85651f28eae278e62a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882fff08678cb85651f28eae278e62a6">&#9670;&nbsp;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::remove_edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eidx index of edge to remove </p>
<p>référence vers le <a class="el" href="class_edge.html">Edge</a> à enlever</p>
<p>Tester la cohérence : nombre d'arc entrants et sortants des sommets 1 et 2</p>
<p>Il reste encore à virer l'arc supprimé de la liste des entrants et sortants des 2 sommets to et from ! References sur les listes de edges des sommets from et to <br />
<br />
 test : on a bien des éléments interfacés</p>
<p>Tester la cohérence : nombre d'arc entrants et sortants des sommets 1 et 2 </p>

</div>
</div>
<a id="a5b93af5c5904031686de3ec9c153046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b93af5c5904031686de3ec9c153046d">&#9670;&nbsp;</a></span>remove_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::remove_vertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference vers le sommet (vertex) a enlever</p>
<p>on supprime toutes les aretes liées a ce sommet</p>
<p>on supprime tous les elements interfacés</p>
<p>on supprime le sommet </p>

</div>
</div>
<a id="a57fa1e332c0475aef878dfd913b18c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fa1e332c0475aef878dfd913b18c82">&#9670;&nbsp;</a></span>remplir_tab_adj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::remplir_tab_adj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour remplir le tableau d'adjaence </p>
<p>Tableau ddjance remlpi à partir des maps de sommets et d'arrêtes, modifiable en cours d'execution du code. </p>
<p>on initialise le tableau de taille ordre*ordre à 0</p>
<p>1er parcours du map de sommets</p>
<p>2eme parcours du map de sommets</p>
<p>si le sommet de partant n'est pas le même que celui d'arrivée</p>
<p>on parcourt toutes les aretes sortant du sommet partant</p>
<p>on parcourt toutes les aretes entrant du sommet d'arrivée</p>
<p>et si on trouve une arete sortant du sommet partant qui est la même de celle d'arrivée</p>
<p>on attribue 1 au tableau d'adjacence de ligne du sommet de partant et de colonne du sommet d'arrivée</p>
<p>sinon si le sommet de partant est le même que celui d'arrivée</p>
<p>on attrbue 1 au tableau d'adjacenet de ligne du sommet de partant et de colonne d'arrivée car un sommet est forcément adjacent à lui même </p>

</div>
</div>
<a id="ae44f38ee6feb9ba496c5747875b4daeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44f38ee6feb9ba496c5747875b4daeb">&#9670;&nbsp;</a></span>remplir_tab_adj_sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::remplir_tab_adj_sym </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour remplir le tableau d'adjacence symétrique </p>
<p>on initialise le tableau de taille ordre*ordre à 0</p>
<p>1er parcours du map de sommets</p>
<p>2eme parcours du map de sommets</p>
<p>si les deux sommets sont actifs (ne sont pas supprimés de l'interface pour tester la k-connexité)</p>
<p>si le sommet de partant n'est pas le même que celui d'arrivée</p>
<p>on parcourt toutes les aretes sortant du sommet partant</p>
<p>on parcourt toutes les aretes entrant du sommet d'arrivée</p>
<p>et si on trouve une arete sortant du sommet partant qui est la même de celle d'arrivée</p>
<p>on attribue 1 au tableau d'adjacence de ligne du sommet de partant et de colonne du sommet d'arrivée</p>
<p>on attribue 1 au tableau d'adjacence de ligne du sommet d'arrivée et de colonne du sommet de partant</p>
<p>sinon si le sommet de partant est le même que celui d'arrivée</p>
<p>on attrbue 1 au tableau d'adjacenet de ligne du sommet de partant et de colonne d'arrivée car un sommet est forcément adjacent à lui même</p>
<p>on attrbue 1 au tableau d'adjacenet de ligne du sommet d'arrivée et de colonne de partant car un sommet est forcément adjacent à lui même </p>

</div>
</div>
<a id="a1ffa2a4e949cf2c6fef1d3c6b6aff000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa2a4e949cf2c6fef1d3c6b6aff000">&#9670;&nbsp;</a></span>remplir_tab_connexe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::remplir_tab_connexe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode pour remplir le tableau de connexité </p>
<p>tableau dynamique contenant les composantes connexes</p>
<p>tableau dynamique indiquant si les sommets sont marqués ou non</p>
<p>numéros des sommets intermédiares des composantes connexes</p>
<p>booléen indiquant si une nouvelle composante connexe est ajoutée</p>
<p>on recupère dans un veteur l'etat de tous les sommets</p>
<p>on intialise le tableau de marquage à 0</p>
<p>on initialise le tableau de connexité à 0 sauf les sommets desactives à 1</p>
<p>on attribue 1 au tableau de connexité pour le sommet de reference car il est forcément connexe à lui-même</p>
<p>tant que toutes les composantes connexe ne sont pas ajoutées, on effectue ce qui est dans la boucle</p>
<p>on met ajoute à 0 et s'il y a une nouvelle composante donc le code va rentrer dans la condition if et ajoute revient à 1 ce qui permettra l'exection de la boucle du nouveau</p>
<p>on parcours de 0 à l'ordre du graphe</p>
<p>si on trouve un sommet connexe à s et non marqué</p>
<p>on le marque</p>
<p>on parcours de nouveau de 0 à l'ordre du graphe</p>
<p>si on trouve un sommet adjacent au sommet x et non marqué et actif</p>
<p>on ajoute ce sommet en tant que sommet connexe avec le sommet de s</p>
<p>on remet ajoute à 1</p>
<p>on retourne le tableau de connexité </p>

</div>
</div>
<a id="a3cc48e35c7f5c6b41fd13da140fe138e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc48e35c7f5c6b41fd13da140fe138e">&#9670;&nbsp;</a></span>toutesLesComposantesFortementConnexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::toutesLesComposantesFortementConnexes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode permettant de trouver toutes les compsantes fortement connexe </p>
<p>tableau dynamique des composantes fortements connexes à retourner</p>
<p>tableau dynamique indiquant si les sommets sont marqués ou non</p>
<p>numéros de sommets intermédiaires des composantes connexes</p>
<p>on initialise les deux tableaux à 0</p>
<p>on parcourt de 0 à l'ordre du graphe</p>
<p>on attribue comme sommet de ref pour le sous prog Unecomposantefortementconnexe x et on remplit tabc à la ligne x par le tableau qu'on recupère depuis le sous prog UneComposanteFortementConnexe <br />
<br />
<br />
<br />
<br />
 et on marque x</p>
<p>on parcours de nouveau de 0 à l'ordre du graphe</p>
<p>si le sommet de partant x et le sommet d'arrivee y sont fortement connexe et y est non marqué</p>
<p>on marque y</p>
<p>on retourne le tableau contenant toutes les composantes fortement connexe du graphe </p>

</div>
</div>
<a id="a357f45443c2007210ffb24fc76e1a2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357f45443c2007210ffb24fc76e1a2b7">&#9670;&nbsp;</a></span>uneComposanteFortementConnexe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::uneComposanteFortementConnexe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>methode permettant de trouver une compsante fortement connexe </p>
<p>composantes connexes directes partant de s et indirectes arrivant vers s</p>
<p>composante fortement connexe à retourner</p>
<p>tableau dynamique indiquant si les sommets sont marqués ou non</p>
<p>numéros de sommets intermédiaires des composantes connexes</p>
<p>booléen indiquant si une nouvelle composante connexe est ajoutée</p>
<p>on initialise toutes les tableaux à 0</p>
<p>on attribue 1 au tableau de connexité pour le sommet de reference car il est forcément connexe à lui-même</p>
<p>tant que toutes les composantes connexe ne sont pas ajoutées, on effectue ce qui est dans la boucle</p>
<p>on met ajoute à 0 et s'il y a une nouvelle composante donc le code va rentrer dans la condition if et ajoute revient à 1 ce qui permettra l'exection de la boucle du nouveau</p>
<p>on parcours de 0 à l'ordre du graphe</p>
<p>si on trouve un sommet connexe directe partant de s et non marqué</p>
<p>on le marque</p>
<p>on parcours de nouveau de 0 à l'ordre du graphe</p>
<p>si on trouve un sommet adjacent au sommet x et non marqué</p>
<p>on ajoute ce sommet en tant que sommet connexe avec le sommet de s en partant de s</p>
<p>on remet ajoute à 1</p>
<p>on re-intialise le tableau de marquage à 0</p>
<p>même principe que la connexité partant directement de s mais pour le cas où on arrive indirectement à s</p>
<p>on associe ces 2 tableaux dans un seul tableau pour obtenir une composante fortement connexe pour le sommet S s'il existe </p>

</div>
</div>
<a id="a97b4fe3e0f119971649ed33e3c364cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4fe3e0f119971649ed33e3c364cde">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La méthode update à appeler dans la boucle de jeu pour les graphes avec interface. </p>
<p>a placer au milieu </p>

</div>
</div>
<a id="ac8b2b52cbbdd6048dfcee5e8f7a72782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b2b52cbbdd6048dfcee5e8f7a72782">&#9670;&nbsp;</a></span>WraperBoutons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::WraperBoutons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>play/ pause evolution</p>
<p>play/ pause evolution</p>
<p>play/ pause evolution</p>
<p>ralentissement evolution</p>
<p>acceleration evolution</p>
<p>sauvegarde</p>
<p>sauvegarde</p>
<p>restauration</p>
<p>quiter</p>
<p>montrer composantes connexe</p>
<p>ajouter sommet</p>
<p>ajouter arete</p>
<p>supprimer arete (pas tres tres bon) </p>

</div>
</div>
<hr/>La documentation de cette classe a Ã©tÃ© gÃ©nÃ©rÃ©e Ã  partir des fichiers suivants :<ul>
<li><a class="el" href="graph_8h_source.html">graph.h</a></li>
<li>adjacence.cpp</li>
<li>fichiers.cpp</li>
<li>graph.cpp</li>
<li>interface.cpp</li>
<li>K-connexite.cpp</li>
<li>simu_pop.cpp</li>
<li>update.cpp</li>
<li>wrapper_menu.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_graph.html">Graph</a></li>
    <li class="footer">GÃ©nÃ©rÃ© par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
